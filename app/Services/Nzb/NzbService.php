<?php

declare(strict_types=1);

namespace App\Services\Nzb;

use App\Models\Binary;
use App\Models\Collection;
use App\Models\Part;
use App\Models\Release;
use App\Models\Settings;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

/**
 * Service for managing NZB files on disk.
 * Handles reading, writing, and path management for NZB files.
 */
class NzbService
{
    public const NZB_NONE = 0; // Release has no NZB file yet.

    public const NZB_ADDED = 1; // Release had an NZB file created.

    protected const NZB_DTD_NAME = 'nzb';

    protected const NZB_DTD_PUBLIC = '-//newzBin//DTD NZB 1.1//EN';

    protected const NZB_DTD_EXTERNAL = 'http://www.newzbin.com/DTD/nzb/nzb-1.1.dtd';

    protected const NZB_XML_NS = 'http://www.newzbin.com/DTD/2003/nzb';

    /**
     * Levels deep to store NZB files.
     */
    protected int $nzbSplitLevel;

    /**
     * Path to store NZB files.
     */
    protected string $siteNzbPath;

    /**
     * String used for head in NZB XML file.
     */
    protected string $nzbCommentString;

    protected string $siteCommentString;

    public function __construct()
    {
        $nzbSplitLevel = (int) Settings::settingValue('nzbsplitlevel');
        $this->nzbSplitLevel = $nzbSplitLevel;
        $this->siteNzbPath = config('nntmux_settings.path_to_nzbs');
        if (! Str::endsWith($this->siteNzbPath, '/')) {
            $this->siteNzbPath .= '/';
        }
        $this->nzbCommentString = sprintf(
            'NZB Generated by: NNTmux %s',
            now()->format('F j, Y, g:i a O')
        );
        $this->siteCommentString = sprintf(
            'NZB downloaded from %s',
            config('app.name')
        );
    }

    /**
     * Write an NZB file for a release.
     *
     * @throws \Throwable
     */
    public function writeNzbForReleaseId(Release $release): bool
    {
        $collections = Collection::whereReleasesId($release->id)
            ->join('usenet_groups', 'collections.groups_id', '=', 'usenet_groups.id')
            ->select(['collections.*', DB::raw('UNIX_TIMESTAMP(collections.date) AS udate'), 'usenet_groups.name as groupname'])
            ->get();

        if (empty($collections)) {
            return false;
        }

        $XMLWriter = new \XMLWriter;
        $XMLWriter->openMemory();
        $XMLWriter->setIndent(true);
        $XMLWriter->setIndentString('  ');

        $nzb_guid = '';

        $XMLWriter->startDocument('1.0', 'UTF-8');
        $XMLWriter->startDtd(self::NZB_DTD_NAME, self::NZB_DTD_PUBLIC, self::NZB_DTD_EXTERNAL);
        $XMLWriter->endDtd();
        $XMLWriter->writeComment($this->nzbCommentString);

        $XMLWriter->startElement('nzb');
        $XMLWriter->writeAttribute('xmlns', self::NZB_XML_NS);
        $XMLWriter->startElement('head');
        $XMLWriter->startElement('meta');
        $XMLWriter->writeAttribute('type', 'category');
        $XMLWriter->text(! empty($release->category->parent) ? $release->category->parent->title.' >'.$release->category->title : 'Other > Misc');
        $XMLWriter->endElement();
        $XMLWriter->startElement('meta');
        $XMLWriter->writeAttribute('type', 'name');
        $XMLWriter->text($release->name);
        $XMLWriter->endElement();
        $XMLWriter->endElement(); // head

        foreach ($collections as $collection) {
            $binaries = Binary::whereCollectionsId($collection->id)->select(['id', 'name', 'totalparts'])->orderBy('name')->get();
            if (empty($binaries)) {
                return false;
            }

            $poster = $collection->fromname;

            foreach ($binaries as $binary) {
                $parts = Part::whereBinariesId($binary->id)->distinct()->select(['messageid', 'size', 'partnumber'])->orderBy('partnumber')->get();
                if (empty($parts)) {
                    return false;
                }

                $subject = $binary->name.'(1/'.$binary->totalparts.')';
                $XMLWriter->startElement('file');
                $XMLWriter->writeAttribute('poster', (string) $poster);
                $XMLWriter->writeAttribute('date', (string) $collection->udate);
                $XMLWriter->writeAttribute('subject', (string) $subject);
                $XMLWriter->startElement('groups');
                if (preg_match_all('#(\S+):\S+#', $collection->xref, $hits)) {
                    $hits = array_values(array_unique($hits[1]));
                    foreach ($hits as $group) {
                        $XMLWriter->writeElement('group', $group);
                    }
                } elseif (preg_match_all('#(\S+)#', $collection->xref, $hits)) {
                    $hits = array_values(array_unique($hits[1]));
                    foreach ($hits as $group) {
                        $XMLWriter->writeElement('group', $group);
                    }
                } else {
                    return false;
                }
                $XMLWriter->endElement(); // groups
                $XMLWriter->startElement('segments');
                foreach ($parts as $part) {
                    if ($nzb_guid === '') {
                        $nzb_guid = $part->messageid;
                    }
                    $XMLWriter->startElement('segment');
                    $XMLWriter->writeAttribute('bytes', (string) $part->size);
                    $XMLWriter->writeAttribute('number', (string) $part->partnumber);
                    $XMLWriter->text($part->messageid);
                    $XMLWriter->endElement();
                }
                $XMLWriter->endElement(); // segments
                $XMLWriter->endElement(); // file
            }
        }
        $XMLWriter->writeComment($this->siteCommentString);
        $XMLWriter->endElement(); // nzb
        $XMLWriter->endDocument();
        $path = ($this->buildNzbPath($release->guid, $this->nzbSplitLevel, true).$release->guid.'.nzb.gz');
        $fp = gzopen($path, 'wb7');
        if (! $fp) {
            return false;
        }
        gzwrite($fp, $XMLWriter->outputMemory());
        gzclose($fp);
        unset($XMLWriter);
        if (! File::isFile($path)) {
            echo "ERROR: $path does not exist.\n";

            return false;
        }
        // Mark release as having NZB.
        $release->update(['nzbstatus' => self::NZB_ADDED]);
        if (! empty($nzb_guid)) {
            $release->update(['nzb_guid' => DB::raw('UNHEX( '.escapeString(md5($nzb_guid)).' )')]);
        }

        // Delete CBP (Collections, Binaries, Parts) for release that has its NZB created.
        // Use a transaction to ensure cascading deletes complete properly.
        try {
            DB::transaction(function () use ($release) {
                Collection::query()->where('releases_id', $release->id)->delete();
            });
        } catch (\Throwable $e) {
            // Log the error but don't fail the NZB creation since the file was written successfully
            Log::warning('Failed to delete collections for release '.$release->id.': '.$e->getMessage());
        }

        // Chmod to fix issues some users have with file permissions.
        chmod($path, 0777);

        return true;
    }

    /**
     * Build a folder path on the hard drive where the NZB file will be stored.
     *
     * @param  string  $releaseGuid  The guid of the release.
     * @param  int  $levelsToSplit  How many sub-paths the folder will be in.
     * @param  bool  $createIfNotExist  Create the folder if it doesn't exist.
     * @return string $nzbpath The path to store the NZB file.
     */
    public function buildNzbPath(string $releaseGuid, int $levelsToSplit, bool $createIfNotExist): string
    {
        $nzbPath = '';

        for ($i = 0; $i < $levelsToSplit && $i < 32; $i++) {
            $nzbPath .= $releaseGuid[$i].'/';
        }

        $nzbPath = $this->siteNzbPath.$nzbPath;

        if ($createIfNotExist && ! File::isDirectory($nzbPath) && ! File::makeDirectory($nzbPath, 0777, true) && ! File::isDirectory($nzbPath)) { // @phpstan-ignore booleanNot.alwaysTrue
            throw new \RuntimeException(sprintf('Directory "%s" was not created', $nzbPath));
        }

        return $nzbPath;
    }

    /**
     * Retrieve path + filename of the NZB to be stored.
     *
     * @param  string  $releaseGuid  The guid of the release.
     * @param  int  $levelsToSplit  How many sub-paths the folder will be in. (optional)
     * @param  bool  $createIfNotExist  Create the folder if it doesn't exist. (optional)
     * @return string Path+filename.
     */
    public function getNzbPath(string $releaseGuid, int $levelsToSplit = 0, bool $createIfNotExist = false): string
    {
        if ($levelsToSplit === 0) {
            $levelsToSplit = $this->nzbSplitLevel;
        }

        return $this->buildNzbPath($releaseGuid, $levelsToSplit, $createIfNotExist).$releaseGuid.'.nzb.gz';
    }

    /**
     * Determine if an NZB exists, returning the path+filename, if not return false.
     *
     * @param  string  $releaseGuid  The guid of the release.
     * @return false|string On success: (string) Path+file name of the nzb.
     *                      On failure: false.
     */
    public function nzbPath(string $releaseGuid): bool|string
    {
        $nzbFile = $this->getNzbPath($releaseGuid);

        return File::isFile($nzbFile) ? $nzbFile : false;
    }

    /**
     * Read and decompress an NZB file contents.
     *
     * @param  string  $releaseGuid  The release GUID
     * @return string|false The decompressed NZB contents or false on failure
     */
    public function readNzbContents(string $releaseGuid): string|false
    {
        $nzbPath = $this->nzbPath($releaseGuid);
        if ($nzbPath === false) {
            return false;
        }

        $contents = unzipGzipFile($nzbPath);

        return ! empty($contents) ? $contents : false;
    }

    /**
     * Delete an NZB file.
     *
     * @param  string  $releaseGuid  The release GUID
     * @return bool True if deleted, false otherwise
     */
    public function deleteNzb(string $releaseGuid): bool
    {
        $nzbPath = $this->nzbPath($releaseGuid);
        if ($nzbPath === false) {
            return false;
        }

        return File::delete($nzbPath);
    }

    /**
     * Get the default NZB split level.
     */
    public function getNzbSplitLevel(): int
    {
        return $this->nzbSplitLevel;
    }

    /**
     * Get the base NZB storage path.
     */
    public function getSiteNzbPath(): string
    {
        return $this->siteNzbPath;
    }
}
